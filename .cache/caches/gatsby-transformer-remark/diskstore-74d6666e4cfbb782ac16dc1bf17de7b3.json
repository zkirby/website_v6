{"expireTime":9007200871020005000,"key":"transformer-remark-markdown-html-94c6f018b969a12b05f3076f0a5e85b3--","val":"<h1>WebAssembly</h1>\n<h3>Resources</h3>\n<ul>\n<li><a href=\"https://mbebenita.github.io/WasmExplorer/\">https://mbebenita.github.io/WasmExplorer/</a></li>\n<li>\n<h2><a href=\"https://developer.mozilla.org/en-US/docs/WebAssembly\">https://developer.mozilla.org/en-US/docs/WebAssembly</a></h2>\n</li>\n</ul>\n<h3>Notes</h3>\n<ul>\n<li>A way to run other programming languages (besides JavaScript) in the browser.</li>\n<li>Much faster than just executing JS in the browser. </li>\n<li>\n<p>Can in theory pre-compile things like modules, etc and then just use those pre-compiled modules which would be much much faster. </p>\n<ul>\n<li>Someone could author a npm package in Rust, and JS devs could use it. </li>\n</ul>\n</li>\n<li>C -> IR -> WebAssembly -> x86/ARM. Key is that the hop from web assembly to the real assembly is very short and very very fast.</li>\n<li>It's faster since wasm is already in byte code, it just needs to be translated (instead of parsed in to an AST) which is much much faster. </li>\n<li>Will probably replace modules. Allow code re-use between web and native platforms. </li>\n<li>This only works for compiled languages (C, Rust, ect).</li>\n</ul>"}