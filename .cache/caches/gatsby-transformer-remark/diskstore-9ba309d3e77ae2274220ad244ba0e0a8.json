{"expireTime":9007200871023418000,"key":"transformer-remark-markdown-html-4a84c8f167e3362887352240539ea705--","val":"<h1>Linux Productivity Tools</h1>\n<p>reference: <a href=\"https://www.usenix.org/sites/default/files/conference/protected-files/lisa19_maheshwari.pdf\">https://www.usenix.org/sites/default/files/conference/protected-files/lisa19_maheshwari.pdf</a>\nUtilizing linux as a productivity environment. Linux is the preferred 'general state of existence' in between command line operations, so knowing it well is important. </p>\n<h3>Basics</h3>\n<ul>\n<li>which <cmdname>: allows you to verify if a command exists.</li>\n<li>help/info <cmd>: best ways to get help or learn about a command.</li>\n<li>diff: best way to compare text files</li>\n<li>lynx <url>: serf the web but only text based.</li>\n<li>curl -o <url>: download things form the web.</li>\n<li>?: expands to exactly one character</li>\n<li>!: used for negation ls -ld [!0-9]*</li>\n<li>!!: repeats the last command</li>\n<li>\n<p>!$: change command keep last argument.</p>\n<ul>\n<li>touch notes.md; v !$; will create a file and then open it in vim.</li>\n</ul>\n</li>\n<li>!*: change command keep all arguments.</li>\n<li>alt-.: paste last argument of previous command</li>\n<li>alt-<n>-alt-.: paste nth argument of previous command</li>\n<li><cmd> #tag: tags a hard to remember command</li>\n</ul>\n<h3>Streams, pipe, and redirection</h3>\n<ul>\n<li>&#x26;: used to write into a stream. e.g., &#x26;1 to write into stdout.</li>\n<li>To disregard output, just stream into /dev/null. e.g., &#x26;> /dev/null</li>\n<li>\n<p>read from stdin as out of a command:</p>\n<ul>\n<li>diff &#x3C;(ls dirA) &#x3C;(ls dirB)</li>\n</ul>\n</li>\n<li>\n<p>xargs: used when you actually need arguments. Converts standard input to commands into literal args. </p>\n<ul>\n<li>for example: xargs touch &#x3C; somelist.txt will make files for every name listed in somelist.txt. </li>\n</ul>\n</li>\n<li>Gnu parallel can be used for running parallel jobs in case you have a large list of things you need to do. </li>\n</ul>\n<h3>Classic Tools: fing, grep, awk, sed</h3>\n<ul>\n<li>\n<p>find: searches files based on some criteria.</p>\n<ul>\n<li>ex) find /opt -name \"README*\" -exec wc -l {} +\n[path] [  critera   ] [   action    ]</li>\n<li>can have multiple paths just spaced apart.</li>\n</ul>\n</li>\n<li>\n<p>grep: used to fetch lines from a text that have a specific pattern. </p>\n<ul>\n<li>you can tag commands with '#[something]' and then search for them later with grep, e.g. history | grep #[something]</li>\n</ul>\n</li>\n<li>you can use find in grep in combination to look for some text over some set of files. </li>\n<li>awk: extract and manipulate data. A programmable filter that reads and processes input line by line. </li>\n<li>\n<p>sed: parse and transform text</p>\n<ul>\n<li>ex: sed 's/New/old/g' state.txt\n[command][regex][replace][modifier]  [input]</li>\n<li>modifier: apply to nth occurrence (g = all occurrences) </li>\n</ul>\n</li>\n</ul>\n<h3>Bash Tools</h3>\n<ul>\n<li>\n<p>|| and &#x26;&#x26; operators work logically.</p>\n<ul>\n<li>A || B = run B iff A fails</li>\n<li>A &#x26;&#x26; B = run B iff A succeeds</li>\n</ul>\n</li>\n<li>.bashrc: runs in each new shell that is spawned</li>\n<li>.bash_profile: a file that runs only in a \"login shell\" (e.g. not sub shells)</li>\n<li>use '' to bypass an alias. e.g. \\cat</li>\n<li>can use $(cmd | cmd) to save commands to variables. </li>\n</ul>\n<h3>Miscellaneous Utilities</h3>\n<ul>\n<li>at: executes a command on a specific day and time </li>\n<li>cron: executes a desired command periodically. </li>\n<li>\n<p>python3: can run one line small programs with python</p>\n<ul>\n<li>python3 -c \"print('hello')\"</li>\n</ul>\n</li>\n</ul>"}